*FactorialExercise*
Re-define the factorial function

*FactorialForComprehension*
Calculate the factorial of some numbers in a list and send in output factorials%3==0

*MultDivWithDoubleStar*
Create a script that executes division or multiplication and that it explain the operation
Parameters for div/mult and explain-output are passed as keyword

*PassingFunctionAsArgument*
Create a script that pass a function as argument in another function

*RecursiveAppend*
Create a function that recursively appends objects to an array

*SumWithStar*
Create a function that sum a list of integer parameters using the star

*WritingReadingFileTest*
Create a script that allows the user to write on a file
The output will be displayed after the input

*FactorialWithStacks.py*
Add in a stack 5 numbers. It will calculate all factorials and it will filter all factorials%2==0 in another stack

*InstancesCounter.py*
Create a script that counts the instances of a class

*CounterWithDecorator.py*
Create a decorator that counts all instances of a class

*SingletonTest.py*
Create a single administrator that can ban/unban users

*BiblioExercise.py*
Create a single library that contains multiple books. All params should be privates and should be setted with ensures

*AddMethodToClass.py*
Create a static method that if it can't find a method, it will invoke AnotherClass.f method

*DecoratorFFunct.py*
Create a decorator that if it can't find the f function on a class, it will set a new function to the f attribute 

*MethodRedefinition.py*
Write a class with a __new__ method that associates an inner class function to the primary class

*ListAdaptQueue.py*
Create an adapter that adapts a queue to a list and a stack

*recursiveDeepCopy.py*
Implement a recursive deep copy

*sumDecorator.py*
Write a function that sums all elements passed by argument. Write a decorator that allows the function to accept a list of elements where elements != int and it can convert it to int; then, do the sum

*functionsCounter.py*
Write a decorator that counts all method invocations of a class

*IntegerGenerator.py*
Write a function that accept an integer as argument and it can create a list with 0 to n-1 numbers. Create multiple lists in a list

*AdapterWorks.py*
Write some different classes that has a common function: use an adapter to use that function in a list of objects

*ListPermutation.py*
Create a list that contains all permutations of an another list. All elements must be integers

*IntegerSumGenerator.py*
Create a function that returns a list of n elements that increases like [0, 1, 3, 6, 10, ...] where the last element is equals to 0+1+3+6+10+...+(n-1)

*AddAttributeToClass.py*
Create a function that creates an attribute for the class. If the class already has that attribute, the function returns false

*InvocationFactory.py*
Create a decorator factory that creates a class decorator that counts the invocations of a method, passed as argument in the decorator factory

*DictImplementation.py*
Implement a custom dictionary re-creating all operators as functions. Save the couples key-value in a custom class

*restRoutine.py*
Use the coroutine decorator to create a coroutine that prints OK if the number taken with the send method is divisible by an argument number

*ObsTest.py*
Implement an Observer and a Listener/View with a test system

*ChildrenState.py*
A pattern state exercise: it does operations based on the status of the student

*testMultiplexer.py*
A tester of the new decorator Multiplexer

*packDelivery.py*
Exercise on the State Pattern with packs and deliveries

*rangeOfResponsability.py*
Exercise on the Chain of Responsability Pattern with ranges
